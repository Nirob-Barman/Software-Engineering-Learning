# ЁЯОп рж╕рзНржЯрзНржпрж╛ржХ (Stack) ржирж┐ржпрж╝рзЗ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд тАФ ржбрзЗржлрж┐ржирзЗрж╢ржи, ржЕржкрж╛рж░рзЗрж╢ржирж╕ ржПржмржВ ржЙржжрж╛рж╣рж░ржг (C рж▓рзНржпрж╛ржВржЧрзБрзЯрзЗржЬ)

ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ ржЬржЧрждрзЗ **рж╕рзНржЯрзНржпрж╛ржХ** ржПржХржЯрж┐ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░, ржпрж╛ **Last In First Out (LIFO)** ржирзАрждрж┐рждрзЗ ржХрж╛ржЬ ржХрж░рзЗред ржЖржЬржХрзЗ ржЖржорж░рж╛ ржЬрж╛ржиржм:

* рж╕рзНржЯрзНржпрж╛ржХ ржХрзА
* ржХрзАржнрж╛ржмрзЗ ржПржЯрж┐ ржХрж╛ржЬ ржХрж░рзЗ
* ржХрзА ржХрзА ржЕржкрж╛рж░рзЗрж╢ржи ржХрж░рж╛ ржпрж╛ржпрж╝
* ржмрж╛рж╕рзНрждржм ржЙржжрж╛рж╣рж░ржг рж╕рж╣ ржмрзНржпрж╛ржЦрзНржпрж╛

ржЖржорж░рж╛ ржЙржжрж╛рж╣рж░ржг рж╣рж┐рж╕рзЗржмрзЗ C рж▓рзНржпрж╛ржВржЧрзБрзЯрзЗржЬ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмред

## 1. Stack Definition (рж╕рзНржЯрзНржпрж╛ржХ ржбрзЗржлрж┐ржирзЗрж╢ржи)
рж╕рзНржЯрзНржпрж╛ржХ рж╣рж▓рзЛ ржПржоржи ржПржХржЯрж┐ ржбрзЗржЯрж╛ рж╕рзНржЯрзНрж░рж╛ржХржЪрж╛рж░ ржпрзЗржЦрж╛ржирзЗ рж╕рж░рзНржмрж╢рзЗрж╖рзЗ ржЗржирж╕рж╛рж░рзНржЯ ржХрж░рж╛ ржЙржкрж╛ржжрж╛ржиржЯрж┐ рж╕ржмрж╛рж░ ржЖржЧрзЗ рж░рж┐ржорзБржн рж╣ржпрж╝ред ржПржЗ ржирзАрждрж┐ржЯрж┐ржХрзЗ ржмрж▓рзЗ LIFO тАУ Last In, First Outред

ржПржХржЯрж╛ ржЯрзЗржмрж┐рж▓рзЗ рж░рж╛ржЦрж╛ ржЯрзНрж░рзЗрж░ рж╕рзНрждрзВржк ржХрж▓рзНржкржирж╛ ржХрж░рзЛред ржпрзЗржЗ ржЯрзНрж░рзЗржЯрж╛ рж╕ржмрж╛рж░ ржЙржкрж░рзЗ ржЖржЫрзЗ, рж╕рзЗржЯрж╛ рж╕ржмрж╛рж░ ржЖржЧрзЗ ржЙржаржмрзЗред ржПржЯрж┐ржЗ рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржмрж╛рж╕рзНрждржм ржЙржжрж╛рж╣рж░ржгред

## 2. Stack Operations (рж╕рзНржЯрзНржпрж╛ржХ ржЕржкрж╛рж░рзЗрж╢ржирж╕)
рж╕рзНржЯрзНржпрж╛ржХрзЗ рж╕рж╛ржзрж╛рж░ржгржд ржкрж╛ржБржЪржЯрж┐ ржорзМрж▓рж┐ржХ ржЕржкрж╛рж░рзЗрж╢ржи ржерж╛ржХрзЗ:
* **push(x)** тЖТ ржЙржкрж░рзЗ ржПржХржЯрж┐ ржЙржкрж╛ржжрж╛ржи ржпрзЛржЧ ржХрж░рзЗ
* **pop()** тЖТ ржЙржкрж░рзЗрж░ ржЙржкрж╛ржжрж╛ржиржЯрж┐ рж╕рж░рж┐ржпрж╝рзЗ ржлрзЗрж▓рзЗ
* **topElement()** тЖТ ржмрж░рзНрждржорж╛ржи ржЯржк ржЙржкрж╛ржжрж╛ржи рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗ
* **isEmpty()** тЖТ рж╕рзНржЯрзНржпрж╛ржХ ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ рждрж╛ ржпрж╛ржЪрж╛ржЗ ржХрж░рзЗ
* **size()** тЖТ рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржмрж░рзНрждржорж╛ржи рж╕рж╛ржЗржЬ ржЬрж╛ржирж╛ржпрж╝

### (a) Push Operation

рж╕рзНржЯрзНржпрж╛ржХрзЗ ржирждрзБржи ржЙржкрж╛ржжрж╛ржи ржпрзЛржЧ ржХрж░рж╛рж░ ржЬржирзНржп Push ржЕржкрж╛рж░рзЗрж╢ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝ред ржЙржкрж╛ржжрж╛ржиржЯрж┐ рж╕ржмрж╕ржоржпрж╝ рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржЙржкрж░рзЗ ржпрзЛржЧ рж╣ржпрж╝ред
```
void push(int stack[], int x, int n) { 
    if (top == n - 1) { // Check if the stack is full
        cout << "Stack is full. Overflow condition!" << endl;
    } else {
        top = top + 1; // Increment the top position
        stack[top] = x; // Insert the element at the top
    }
}
```

### (b) Pop Operation

рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржЙржкрж░рзЗрж░ ржЙржкрж╛ржжрж╛ржиржЯрж┐ рж░рж┐ржорзБржн ржХрж░рж╛рж░ ржЬржирзНржп Pop ржЕржкрж╛рж░рзЗрж╢ржи ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржпрж╝ред
```
void pop() {
    if (isEmpty()) {
        cout << "Stack is empty. Underflow condition!" << endl;
    } else {
        top = top - 1; // Decrement the top position
    }
}
```

### (c) Top Element
рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржЙржкрж░рзЗрж░ ржЙржкрж╛ржжрж╛ржиржЯрж┐ ржЕрзНржпрж╛ржХрзНрж╕рзЗрж╕ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред
```
int topElement(int stack[]) {
    return stack[top];
}
```

### d) isEmpty
рж╕рзНржЯрзНржпрж╛ржХржЯрж┐ ржЦрж╛рж▓рж┐ ржХрж┐ржирж╛ рждрж╛ ржЪрзЗржХ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред
```
bool isEmpty() {
    return top == -1;
}
```

### (e) Size
рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржмрж░рзНрждржорж╛ржи рж╕рж╛ржЗржЬ ржирж┐рж░рзНржгржпрж╝ ржХрж░рж╛рж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рж╣ржпрж╝ред
```
int size() {
    return top + 1;
}
```

## 3. Stack Implementation in C (C рж▓рзНржпрж╛ржВржЧрзБрзЯрзЗржЬрзЗ рж╕рзНржЯрзНржпрж╛ржХ ржЗржоржкрзНрж▓рж┐ржорзЗржирзНржЯрзЗрж╢ржи)
```
#include <iostream>
using namespace std;

int top = -1; // рж╢рзБрж░рзБрждрзЗ рж╕рзНржЯрзНржпрж╛ржХ ржЦрж╛рж▓рж┐

void push(int stack[], int x, int n) {
    if (top == n - 1) {
        cout << "Stack is full. Overflow condition!" << endl;
    } else {
        top = top + 1;
        stack[top] = x;
    }
}

bool isEmpty() {
    return top == -1;
}

void pop() {
    if (isEmpty()) {
        cout << "Stack is empty. Underflow condition!" << endl;
    } else {
        top = top - 1;
    }
}

int size() {
    return top + 1;
}

int topElement(int stack[]) {
    return stack[top];
}

int main() {
    int stack[3];

    push(stack, 100, 3);
    cout << "Current size of stack is " << size() << endl;

    push(stack, 200, 3);
    push(stack, 300, 3);
    cout << "Current size of stack is " << size() << endl;

    push(stack, 400, 3); // Overflow

    cout << "Top element: " << topElement(stack) << endl;

    for (int i = 0; i < 3; i++) {
        pop();
    }
    cout << "Current size of stack is " << size() << endl;

    pop(); // Underflow

    return 0;
}
```

## 4. Output
```
Current size of stack is 1
Current size of stack is 3
Stack is full. Overflow condition!
Top element: 300
Current size of stack is 0
Stack is empty. Underflow condition!
```

## 5. рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржЕрзНржпрж╛ржкрзНрж▓рж┐ржХрзЗрж╢ржи тАФ ржмрзНрж░рзНржпрж╛ржХрзЗржЯ ржмрзНржпрж╛рж▓рзЗржирзНрж╕ ржЪрзЗржХ
ржПржХржЯрж┐ рж╕рзНржЯрзНрж░рж┐ржВ-ржПрж░ ржкрзНрж░ржержо ржПржмржВ рж╢рзЗрж╖ ржмржирзНржзржирзА рж╕ржарж┐ржХржнрж╛ржмрзЗ ржмрзНржпрж╛рж▓рзЗржирзНрж╕ржб ржХрж┐ржирж╛ рждрж╛ ржЪрзЗржХ ржХрж░рждрзЗ рж╕рзНржЯрзНржпрж╛ржХ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛ржпрж╝ред 
